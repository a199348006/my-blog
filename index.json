[{"content":"前言  記錄以物件導向程式設計來寫Javascript(ES6)。\n Class 訪問器及靜態方法 class Person {  constructor (name, age) {  this._name = \u0026#39;Chowder\u0026#39;;  this.age = age;  }   get name() {  console.log(\u0026#39;get\u0026#39;)  return this._name;  }   set name(newValue) {  console.log(\u0026#39;set\u0026#39;)  this._name = newValue;  }   static foo() {  console.log(\u0026#39;it is foo.\u0026#39;)  } }  Person.foo(); // it is foo.  let p = new Person(\u0026#39;Chowder\u0026#39;, 25); console.log(p); // Person { _name: \u0026#39;Chowder\u0026#39;, age: 25 } p.name // get p.name = \u0026#39;Kevin\u0026#39; // set console.log(p) // Person { _name: \u0026#39;Kevin\u0026#39;, age: 25 } Class 繼承 class Person {  constructor (name, age) {  this.name = name;  this.age = age;  }   eating() {  console.log(this.name, \u0026#39;is eating.\u0026#39;)  } }  class Student extends Person {  constructor (name, age, sno) {  super(name, age); // super: call parent constructor  this.sno = sno;  }   studying() {  console.log(this.name, \u0026#39;is studying.\u0026#39;)  }   eating() { // cover parent func  super.eating(); // super: call parent func  console.log(\u0026#39;Student is eating.\u0026#39;)  } }  let s = new Student(\u0026#39;Allen\u0026#39;, 18, 20220001); console.log(s) // Student { name: \u0026#39;Allen\u0026#39;, age: 18, sno: 20220001 } s.eating(); // Allen is eating.  // Student is eating. s.studying(); // Allen is studying. Class 繼承內建Class class myArray extends Array {  firstItem() {  return this[0];  }   lastItem() {  return this[this.length - 1];  } }  let arr = new myArray(9, 8, 7, 6, 5); console.log(arr.firstItem()) console.log(arr.lastItem()) 參考來源 JavaScript物件導向—深入ES6的class\niT邦幫忙\n","permalink":"https://a199348006.github.io/my-blog/2022/03/oop_javascript/","summary":"前言  記錄以物件導向程式設計來寫Javascript(ES6)。\n Class 訪問器及靜態方法 class Person {  constructor (name, age) {  this._name = \u0026#39;Chowder\u0026#39;;  this.age = age;  }   get name() {  console.log(\u0026#39;get\u0026#39;)  return this._name;  }   set name(newValue) {  console.log(\u0026#39;set\u0026#39;)  this._name = newValue;  }   static foo() {  console.log(\u0026#39;it is foo.\u0026#39;)  } }  Person.foo(); // it is foo.  let p = new Person(\u0026#39;Chowder\u0026#39;, 25); console.","title":"物件導向：Javascript"},{"content":"前言  記錄會較常使用的狀態碼，詳細可以下拉至參考來源。\n 2XX成功  200 OK - 在GET請求中，回應將包含與請求的資源相對應的實體。在POST請求中，回應將包含描述或操作結果的實體。 201 Created 204 No Content - 伺服器成功處理了請求，沒有返回任何內容。  3XX重新導向  304 Not Modified - 表示資源在由請求頭中的If-Modified-Since或If-None-Match參數指定的這一版本之後，未曾被修改。  4XX客戶端錯誤  400 Bad Request 401 Unauthorized - 未提供或無效的身份驗證Token時 403 Forbidden - 身份驗證成功但無權訪問資源 404 Not Found 405 Method Not Allowed - 當請求的HTTP方法不允許經過身份驗證的用戶時 415 Unsupported Media Type - 如果作為請求的一部分提供了錯誤的內容類型 422 Unprocessable Entity - 用於欄位資料驗證錯誤 429 Too Many Requests  5XX伺服器錯誤  500 Internal Server Error - 伺服器端程式有誤，需要工程師修復  參考來源 維基百科\niT邦幫忙\n","permalink":"https://a199348006.github.io/my-blog/2022/03/http_status_code/","summary":"前言  記錄會較常使用的狀態碼，詳細可以下拉至參考來源。\n 2XX成功  200 OK - 在GET請求中，回應將包含與請求的資源相對應的實體。在POST請求中，回應將包含描述或操作結果的實體。 201 Created 204 No Content - 伺服器成功處理了請求，沒有返回任何內容。  3XX重新導向  304 Not Modified - 表示資源在由請求頭中的If-Modified-Since或If-None-Match參數指定的這一版本之後，未曾被修改。  4XX客戶端錯誤  400 Bad Request 401 Unauthorized - 未提供或無效的身份驗證Token時 403 Forbidden - 身份驗證成功但無權訪問資源 404 Not Found 405 Method Not Allowed - 當請求的HTTP方法不允許經過身份驗證的用戶時 415 Unsupported Media Type - 如果作為請求的一部分提供了錯誤的內容類型 422 Unprocessable Entity - 用於欄位資料驗證錯誤 429 Too Many Requests  5XX伺服器錯誤  500 Internal Server Error - 伺服器端程式有誤，需要工程師修復  參考來源 維基百科","title":"HTTP Status Code"},{"content":"前言  氣泡排序(Bubble Sort)又稱為冒泡排序、泡沫排序，是排序演算法中最簡單的，但運行時間是最差的。\n  穩定排序 時間複雜度  最佳：\\( O(n\\log n) \\) 最差：\\( O(n^2) \\) 平均：\\( O(n^2) \\)   空間複雜度：\\( O(1) \\)  操作流程  Round 1  比較相鄰元素，前者大於後者就相互交換 從頭到尾執行，確保最後一個元素為最大值   Round 2  扣除最後一個元素，並重複Round 1    實際操作 function swap(arr, index1, index2) {  const temp = arr[index1];  arr[index1] = arr[index2];  arr[index2] = temp; }  function bubbleSort(arr) {  const n = arr.length;  let swapped = true;  for (let i = 0; (i \u0026lt; n - 1) \u0026amp;\u0026amp; swapped; i++) {  swapped = false;  for (let j = 0; j \u0026lt; n - 1 - i; j++) {  if(arr[j] \u0026gt; arr[j + 1]) {  swapped = true;  swap(arr, j, j + 1);  }  }  }  return arr; } 參考來源 JavaScript 學演算法\n","permalink":"https://a199348006.github.io/my-blog/2022/03/bubble-sort/","summary":"前言  氣泡排序(Bubble Sort)又稱為冒泡排序、泡沫排序，是排序演算法中最簡單的，但運行時間是最差的。\n  穩定排序 時間複雜度  最佳：\\( O(n\\log n) \\) 最差：\\( O(n^2) \\) 平均：\\( O(n^2) \\)   空間複雜度：\\( O(1) \\)  操作流程  Round 1  比較相鄰元素，前者大於後者就相互交換 從頭到尾執行，確保最後一個元素為最大值   Round 2  扣除最後一個元素，並重複Round 1    實際操作 function swap(arr, index1, index2) {  const temp = arr[index1];  arr[index1] = arr[index2];  arr[index2] = temp; }  function bubbleSort(arr) {  const n = arr.","title":"泡沫排序(bubble sort)"},{"content":"前言  時間複雜度為 O(n log n) 的演算法。\n  穩定排序 時間複雜度  最佳：\\( O(n\\log n) \\) 最差：\\( O(n\\log n) \\) 平均：\\( O(n\\log n) \\)   空間複雜度：\\( O(n) \\)  操作流程  拆分  把大陣列切一半成為兩個小陣列 把切好的兩個小陣列再各自切一半 重複步驟二直到每個小陣列都只剩一個元素   合併  排序兩個只剩一個元素的小陣列並合併 把兩邊排序好的小陣列合併並排序成一個陣列 重複步驟二直到所有小陣列都合併成一個大陣列    實際操作  合併排序的實現方法有兩種：遞迴結構、迭代結構。\n 遞迴結構實作 function merge(leftArr, rightArr) {  let temp = [];  let [leftIndex, rightIndex] = [0, 0];   while (leftIndex \u0026lt; leftArr.length \u0026amp;\u0026amp; rightIndex \u0026lt; rightArr.length) {  if (leftArr[leftIndex] \u0026lt; rightArr[rightIndex]) {  temp.push(leftArr[leftIndex++]);  } else {  temp.push(rightArr[rightIndex++]);  }  }  return [...temp, ...leftArr.slice(leftIndex), ...rightArr.slice(rightIndex)]; }  function mergeSort(arr) {  const n = arr.length;  if (n \u0026lt; 2) return arr;  const midIndex = Math.floor(n / 2);  const leftArray = arr.slice(0, midIndex);  const rightArray = arr.slice(midIndex);   return merge(mergeSort(leftArray), mergeSort(rightArray)); } 參考來源 JavaScript 學演算法 - 合併排序\n排序法進階：合併排序法\n","permalink":"https://a199348006.github.io/my-blog/2022/03/merge-sort/","summary":"前言  時間複雜度為 O(n log n) 的演算法。\n  穩定排序 時間複雜度  最佳：\\( O(n\\log n) \\) 最差：\\( O(n\\log n) \\) 平均：\\( O(n\\log n) \\)   空間複雜度：\\( O(n) \\)  操作流程  拆分  把大陣列切一半成為兩個小陣列 把切好的兩個小陣列再各自切一半 重複步驟二直到每個小陣列都只剩一個元素   合併  排序兩個只剩一個元素的小陣列並合併 把兩邊排序好的小陣列合併並排序成一個陣列 重複步驟二直到所有小陣列都合併成一個大陣列    實際操作  合併排序的實現方法有兩種：遞迴結構、迭代結構。\n 遞迴結構實作 function merge(leftArr, rightArr) {  let temp = [];  let [leftIndex, rightIndex] = [0, 0];   while (leftIndex \u0026lt; leftArr.","title":"合併排序(merge sort)"},{"content":"前言 常見的資料結構  鏈結串列(Linked List) 陣列(Array) 堆疊(Stack) 佇列(Queue) 樹狀結構(Tree) 圖形結構(Graph) 雜湊表(Hash table) 堆積(Heap)  資料結構分類  線性關係 非線性關係(階層、相鄰關係)  鏈結串列(Linked List)   特點：\n 記憶體位置不連續，以隨機的方式儲存 因為不用事先定義好一塊連續的記憶體空間，所以插入或刪除資料都很方便 每個節點知道下一個節點位置，但無法知道上一個節點位置，所以當想查詢特定節點時，必須從頭節點開始走訪    類型：\n 單向鏈結串列(Singly Linked List) 雙向鏈結串列(Doubly Linked List) 迴圈鏈結串列(Circularly Linked List)    陣列(Array)  特點：  通常用來儲存有序串列的相同資料於連續記憶空間 記憶體的配置是在編譯的時候完成 須事先宣告固定的記憶體空間，因此容易造成記憶體浪費 讀取與修改串列的資料時間是固定的 刪除或加入新元素需要移動大量資料    堆疊(Stack)   特點：\n 只能從頂端存取資料 後進先出的原則 屬於抽象資料型態 只需一個指標：top    四種常見的操作：\n push: 存放資料至頂端，回傳新的堆疊 pop: 刪除頂端資料，並回傳新的堆疊 isEmpty: 判斷堆疊是否為空 full: 判斷堆疊是否為滿    佇列(Queue)   特點：\n 先進先出特性 需兩個指標，一個在前端(front)一個在尾端(rear)    四種常見的操作：\n add: 將新的資料加入佇列中 delete: 刪除佇列前端的資料 front: 傳回佇列前端的值 empty: 判斷佇列是否為空    樹狀結構(Tree) 樹的定義與特性：\n 樹是由一個根節點(Root)開始發展，在樹狀結構中的最基本單位，稱為節點 (Node)，而分支出去的節點稱為子節點(Child)。樹是沒有環的結構，且任意兩節點間只有一個唯一路徑，若隨意刪除其中一個枝 (Branch)，就會變兩個樹。\n  節點(Node)：樹狀結構中每一個資料元素都稱為節點 枝(Branch)：節點向下延伸擴展的所用到的枝 根節點(Root)：根節點具有唯一性，是整個樹狀結構最上層的樹根 葉節點(Leaf)：節點之下都沒有子節點稱為葉節點(像樹葉的葉子) 非終端點(Non-terminal Nodes)：除了葉節點外的其他節點 祖先節點(Ancenstors) 與子孫節點 (Descendant) 父節點(Parent)與子節點 (Child) 兄弟節點(Siblings)：同一個父節點的其他節點，稱為兄弟節點 分支度(Dregree)：每個節點所擁有的子節點數 階層(Level)：從樹根開始，向下延伸的層級 樹深(Depth)：節點與節點間的距離。根節點深度為0  樹的類型  二元樹(Binary tree)  歪斜樹(Skewed Tree)：只有左或右節點 嚴格二元樹(Strictly binary tree)：子節點只能為0或2 完滿二元樹(Full Binary Tree)：每個節點都有兩個子節點 完整二元樹(Complete Binary Tree)：由上而下、由左至右排列 二元搜尋樹(Binary Search Tree)：每一個節點的資料大於左邊的子節點  平衡樹  AVL樹(Adelson-Velsky and Landis Tree)：每一個節點的的左邊子節點的高度-右邊子節點的高度只能是 -1、0、1 紅黑樹(Red–black tree)：利用節點顏色，減少平衡操作的旋轉次數        圖形結構(Graph)  圖是由點、邊組成，通常用G=(V,E)表示，V是節點(Vertice)，E是邊(Edge)，圖可以分成有向圖與無向圖，無向圖以(V1,V2)表示，有向圖以\u0026lt;V1,V2\u0026gt;表示。\n 圖的類型  加權圖形(Weighted Graph) 無向圖 有向圖  雜湊表(Hash table) 雜湊表的定義與特性：\n 雜湊表的所儲存的資料元素都有成對的鍵(Key)及值(Value)，將Key經過雜湊函數(Hash Function)後，計算出新的值並放入對應的陣列索引中。若發生雜湊碰撞(collsion)，則使用連結串列的方式儲存。此資料結構方法被廣泛運用在資料庫搜索、關鍵字搜尋、快取等。\n 雜湊表說明\n堆積(Heap)  堆積是圖形結構中的樹狀結構中的一種，用於實踐優先佇列(Priority Queue)。利用保持資料結構的一定規則(從小到大或從大到小)，來確保拿取資料的效率。\n 堆積的定義與特性：\n 堆積一種特殊的二元樹資料結構，但不全然相同，每個節點(node)最多只有兩個子節點，而子節點與父節點之間要維持一定規則，同層的兄弟節點則無規則限制，但同一層要維持從左到右新增節點，滿了才可增加下一層。\n 堆積說明\n參考來源 資料結構概念.pdf\n基本演算法\n資料結構-iT邦\nJavaScript 學演算法\n","permalink":"https://a199348006.github.io/my-blog/2022/03/data-structure/","summary":"前言 常見的資料結構  鏈結串列(Linked List) 陣列(Array) 堆疊(Stack) 佇列(Queue) 樹狀結構(Tree) 圖形結構(Graph) 雜湊表(Hash table) 堆積(Heap)  資料結構分類  線性關係 非線性關係(階層、相鄰關係)  鏈結串列(Linked List)   特點：\n 記憶體位置不連續，以隨機的方式儲存 因為不用事先定義好一塊連續的記憶體空間，所以插入或刪除資料都很方便 每個節點知道下一個節點位置，但無法知道上一個節點位置，所以當想查詢特定節點時，必須從頭節點開始走訪    類型：\n 單向鏈結串列(Singly Linked List) 雙向鏈結串列(Doubly Linked List) 迴圈鏈結串列(Circularly Linked List)    陣列(Array)  特點：  通常用來儲存有序串列的相同資料於連續記憶空間 記憶體的配置是在編譯的時候完成 須事先宣告固定的記憶體空間，因此容易造成記憶體浪費 讀取與修改串列的資料時間是固定的 刪除或加入新元素需要移動大量資料    堆疊(Stack)   特點：\n 只能從頂端存取資料 後進先出的原則 屬於抽象資料型態 只需一個指標：top    四種常見的操作：","title":"資料結構簡介"},{"content":"前言  在這裡只記錄些實作過程中的摘要，若是想觀看圖文並茂的文章及教程可以至最下方的參考來源。\n 套件版本：\n mosquitto: 2.0.14 MQTT Explorer: 0.4.0-beta mqtt.js: 4.3.5  MQTT簡介 MQTT的架構中分為以下三者：\n Publisher(發佈者)：發佈訊息的人 Broker(代理人)：負責接收來自Publisher的訊息並發訊息給Subscribe Subscriber(訂閱者)：接收訊息的人  MQTT訊息格式  Control Header及Remaining Length皆必須存在，已Publish Message來說Variable Header\u0026gt;會放入topic主題，Payload放入傳遞的訊息內容。\n  Control Header Remaining Length Variable Header: topic Payload: message  網路品質(QoS)  MQTT定義了0, 1和2三個層級的品質設定：\n 0: 最多傳送一次(at most once) 1: 至少傳送一次(at leat once) 2: 確實傳送一次(exactly once)   詳細教程\n安裝Mosquitto Windows及相關設定 Mosquitto安裝 Mosquitto Download\n 安裝過程中Service可以取消勾選(手動開啟BQTT Broker功能)\n Service: 手動開啟BQTT Broker功能 Service: 開機執行   防火牆也需要到進階設定-\u0026gt;輸入規則-\u0026gt;新增規則-\u0026gt;將預設port: 1883開啟，輸出規則重複上述操作。\n詳細安裝及防火牆設置參照\nMosquitto conf設定  安裝目錄預設為C:\\Program Files\\mosquitto\n 新增mosquitto\\usrlist.txt 帳號:密碼 admin:admin 執行CMD: mosquitto_passwd.exe -U usrlist.txt，此時可以看看usrlist.txt的變化。\n修改mosquitto\\mosquitto.conf 在文件末端加入\nallow_anonymous false password_file C:\\Programs Files\\mosquitto\\usrlist.txt listener 1883  allow_anonymous false: 不允許匿名登入 password_file: 指定帳號清單的目錄 listener: 指定遠端登入時可以使用的PORT  啟動MQTT Broker mosquitto.exe -c mosquitto.conf -v\n -c: 指定config檔名 -v: verbose mode詳細模式  安裝MQTT Client軟體測試Server連線 MQTT Explorer\n透過MQTT Explorer在Publish中輸入Topic及要傳遞的訊息並送出。(如下圖)\nSubscribe 萬用字元  訂閱主題搭配萬用字元：+ 和 #，來實現訂閱單層或多層相關主題。\n +字元：匹配單一階層的主題名稱 #字元：匹配多層主題名稱，這個字元只放在名稱最後   例：example/topic/+/a，涵蓋：\n example/topic/first/a example/topic/second/a  例：example/topic/#，涵蓋：\n example/topic/first/a example/topic/second/a example/topic/second/b example/topic/third  Node.js with mqtt.js  利用MQTT Explorer發佈訊息時，訂閱者收到訂閱內容。\n const mqtt = require(\u0026#39;mqtt\u0026#39;); const options = {  port: 1883,  clinetId: \u0026#39;chowder\u0026#39;,  username: \u0026#39;username\u0026#39;, // 填入先前設定的帳號密碼  password: \u0026#39;password\u0026#39;, };  const client = mqtt.connect(\u0026#39;mqtt://127.0.0.1\u0026#39;, options); client.on(\u0026#39;connect\u0026#39;, function () {  console.log(\u0026#39;Connecting to mqtt.\u0026#39;);  client.subscribe(\u0026#39;example/topic/#\u0026#39;); });  client.on(\u0026#39;message\u0026#39;, function (topic, msg) {  console.log(topic, msg.toString()); }); 詳細實作教程\nmqtt.js官方說明\n參考來源 MQTT-JIMI\nMQTT-cubie\n","permalink":"https://a199348006.github.io/my-blog/2022/02/mqtt-nodejs/","summary":"前言  在這裡只記錄些實作過程中的摘要，若是想觀看圖文並茂的文章及教程可以至最下方的參考來源。\n 套件版本：\n mosquitto: 2.0.14 MQTT Explorer: 0.4.0-beta mqtt.js: 4.3.5  MQTT簡介 MQTT的架構中分為以下三者：\n Publisher(發佈者)：發佈訊息的人 Broker(代理人)：負責接收來自Publisher的訊息並發訊息給Subscribe Subscriber(訂閱者)：接收訊息的人  MQTT訊息格式  Control Header及Remaining Length皆必須存在，已Publish Message來說Variable Header\u0026gt;會放入topic主題，Payload放入傳遞的訊息內容。\n  Control Header Remaining Length Variable Header: topic Payload: message  網路品質(QoS)  MQTT定義了0, 1和2三個層級的品質設定：\n 0: 最多傳送一次(at most once) 1: 至少傳送一次(at leat once) 2: 確實傳送一次(exactly once)   詳細教程\n安裝Mosquitto Windows及相關設定 Mosquitto安裝 Mosquitto Download\n 安裝過程中Service可以取消勾選(手動開啟BQTT Broker功能)\n Service: 手動開啟BQTT Broker功能 Service: 開機執行   防火牆也需要到進階設定-\u0026gt;輸入規則-\u0026gt;新增規則-\u0026gt;將預設port: 1883開啟，輸出規則重複上述操作。","title":"MQTT and mqtt.js"},{"content":"前言  透過參考文獻實作過後紀錄一下概要。\n 套件版本：\n express: ^4.17.1 multer: ^1.4.4  API Upload File Upload-server-side  其他multer中的options選項可以參考Multer的GitHub官方說明。\n util/middleware.js\nconst multer = require(\u0026#39;multer\u0026#39;)  const storage = multer.diskStorage({  destination: \u0026#39;D:/upload-files\u0026#39;,  filename: function (req, file, callback) {  // 取得上傳的檔案名稱及副檔名作為存入destination的檔名  callback(null, file.originalname)  } }) const upload = multer({ storage: storage }).single(\u0026#39;file\u0026#39;)  exports.uploadFile = (req, res, next) =\u0026gt; {  upload(req, res, function (err) {  if(err instanceof multer.MulterError) {  console.log(\u0026#39;Multer error: \u0026#39;, err)  res.status(400)  } else if(err) {  console.log(\u0026#39;Upload error: \u0026#39;, err)  res.status(400)  } else {  next()  }  }) } routes/index.js\nconst { uploadFile } = require(\u0026#39;../util/middleware\u0026#39;)  router.post(\u0026#39;/upload\u0026#39;, uploadFile, (req, res) =\u0026gt; {  console.log(req.file)  console.log(req.body)  res.status(200) }) Upload-client-side html\n\u0026lt;head\u0026gt;  \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34; integrity=\u0026#34;sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;  \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;myfile\u0026#34;\u0026gt;  \u0026lt;button id=\u0026#34;btn-post\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt;   \u0026lt;script\u0026gt;  $(\u0026#34;#btn-post\u0026#34;).click(function () {  let formData = new FormData()  formData.append(\u0026#39;title\u0026#39;, \u0026#39;This is title.\u0026#39;)  // 與multer().single(\u0026#39;file\u0026#39;)對應  formData.append(\u0026#39;file\u0026#39;, $(\u0026#34;#myfile\u0026#34;).prop(\u0026#34;files\u0026#34;)[0])   axios({  url: \u0026#39;http://localhost:port/upload\u0026#39;,  method: \u0026#39;POST\u0026#39;,  data: formData  })  })  \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Upload-result  將有/無檔案印出的結果差異紀錄。\n result with file\n{ fieldname: \u0026#39;file\u0026#39;, originalname: \u0026#39;ppt.pptx\u0026#39;, encoding: \u0026#39;7bit\u0026#39;, mimetype: \u0026#39;application/vnd.openxmlformats-officedocument.presentationml.presentation\u0026#39;, destination: \u0026#39;D:/upload-files\u0026#39;, filename: \u0026#39;ppt.pptx\u0026#39;, path: \u0026#39;D:\\\\upload-files\\\\ppt.pptx\u0026#39;, size: 341753 } [Object: null prototype] { title: \u0026#39;This is title.\u0026#39; } result without file\nundefined [Object: null prototype] { title: \u0026#39;This is title.\u0026#39;, file: \u0026#39;undefined\u0026#39; } Download File Download-server-side controller/downloadFile.js\nexports.downloadFile = (req, res) =\u0026gt; {  const fileName = req.params.name  const directoryPath = \u0026#39;D:/upload-files/\u0026#39;   res.download(directoryPath + fileName, fileName, (err) =\u0026gt; {  if(err) {  res.status(500).send({ message: \u0026#39;download fail: \u0026#39; + err })  }  }) } routes/index.js\nconst { downloadFile } = require(\u0026#39;../controller/downloadFile\u0026#39;)  router.get(\u0026#39;/downloadFile/:name\u0026#39;, downloadFile) Download-client-side html\naxios({  url: `http://localhost:port/downloadFile/${fileName}`,  method: \u0026#39;GET\u0026#39;,  responseType: \u0026#39;blob\u0026#39;, }).then((response) =\u0026gt; {  const url = window.URL.createObjectURL(new Blob([response.data]));  const link = document.createElement(\u0026#39;a\u0026#39;);  link.href = url;  link.setAttribute(\u0026#39;download\u0026#39;, fileName);  document.body.appendChild(link);  link.click(); }); How to download files using axios\n 另一種下載檔案的方法則是利用window.open，但瀏覽器會自動開啟關閉一個新分頁，就看是否能接受這樣的呈現方式。\n window.open(`http://localhost:port/downloadFile/${fileName}`) 參考來源 Multer example\nExpress: res.download()\n","permalink":"https://a199348006.github.io/my-blog/2022/02/upload-download-file/","summary":"前言  透過參考文獻實作過後紀錄一下概要。\n 套件版本：\n express: ^4.17.1 multer: ^1.4.4  API Upload File Upload-server-side  其他multer中的options選項可以參考Multer的GitHub官方說明。\n util/middleware.js\nconst multer = require(\u0026#39;multer\u0026#39;)  const storage = multer.diskStorage({  destination: \u0026#39;D:/upload-files\u0026#39;,  filename: function (req, file, callback) {  // 取得上傳的檔案名稱及副檔名作為存入destination的檔名  callback(null, file.originalname)  } }) const upload = multer({ storage: storage }).single(\u0026#39;file\u0026#39;)  exports.uploadFile = (req, res, next) =\u0026gt; {  upload(req, res, function (err) {  if(err instanceof multer.","title":"使用Express架設檔案上傳/下載API"},{"content":"前言  網路上已有了許多教學及流程可以參考，在實作過程中還算順利，所以這邊就只附上我個人的參考文獻，並提出些碰到的狀況。\n Q: found no layout file for \u0026ldquo;HTML\u0026rdquo; for \u0026ldquo;page\u0026rdquo; 這是在我推上github之後，想在本地端啟動server所發生的錯誤，解決方式如下：\n重新下載：\n  git submodule init\n  git submodule update\n  參考來源\n參考來源 Hugo介紹\n官方文件-Host on GitHub\n如何將Hugo部落格部署到Github上?\nGitHub Actions\n","permalink":"https://a199348006.github.io/my-blog/2022/01/hugo/","summary":"前言  網路上已有了許多教學及流程可以參考，在實作過程中還算順利，所以這邊就只附上我個人的參考文獻，並提出些碰到的狀況。\n Q: found no layout file for \u0026ldquo;HTML\u0026rdquo; for \u0026ldquo;page\u0026rdquo; 這是在我推上github之後，想在本地端啟動server所發生的錯誤，解決方式如下：\n重新下載：\n  git submodule init\n  git submodule update\n  參考來源\n參考來源 Hugo介紹\n官方文件-Host on GitHub\n如何將Hugo部落格部署到Github上?\nGitHub Actions","title":"使用Hugo部署至GitHub"},{"content":"更改XAMPP文字編輯器  點右上角config鈕 在Editor方塊內選文字編輯器(ex:Notepad++)   更改phpMyAdmin認證模式，開啟檔案：phpMyAdmin(config.inc.php)  將[\u0026lsquo;auth_type\u0026rsquo;] = \u0026lsquo;config\u0026rsquo;; 改成 [\u0026lsquo;auth_type\u0026rsquo;] = \u0026lsquo;cookie\u0026rsquo;; (網頁式密碼輸入對話框) 或 [\u0026lsquo;auth_type\u0026rsquo;] = \u0026lsquo;http\u0026rsquo;; (彈出式密碼輸入對話框) 如果改成\u0026rsquo;http\u0026rsquo;，則可修改密鑰 $cfg[\u0026lsquo;blowfish_secret\u0026rsquo;] = \u0026lsquo;xampp\u0026rsquo; (不改也可) 儲存後重新啟動控制面板   啟動如出現錯誤  檢查xampp是否放置於中文資料夾 點選右側NetStat鈕 ，查看80(http)、443(https)、3306(MySQL)Port是否被佔用   更改http 80port為8080port，開啟檔案：Apache(httpd.conf)   搜尋80(有兩處要改)\nListen 8080\nServerName localhost:8080\n   更改預設首頁資料夾，開啟檔案：Apache(httpd.conf)  搜尋 \u0026lsquo;htdocs\u0026rsquo; 修改路徑1：DocumentRoot \u0026ldquo;C:/xampp/htdocs/xxxxx\u0026rdquo; 修改路徑2：Directory \u0026ldquo;C:/xampp/htdocs/xxxxx\u0026rdquo;  P.S. 也可在C:\\XAMPP\\htdocs中修改index.php內容：header(\u0026lsquo;Location: \u0026lsquo;.$uri.\u0026rsquo;/xxx/\u0026rsquo;);\n 避免瀏覽器列出檔案目錄，開啟檔案：Apache(httpd.conf)  上面更改htdocs的位置下方 Options Indexes FollowSymLinks Includes ExecCGI (刪除Indexes)   更改PHP能使用短標籤，開啟檔案：PHP(php.ini)  搜尋 \u0026lsquo;short\u0026rsquo; 更改為 short_open_tag=on   更改時區，開啟檔案：PHP(php.ini)  將內容拉至最下方 修改為 date.timezone=Asia/Taipei   是否顯示錯誤訊息，開啟檔案：PHP(php.ini)  搜尋\u0026rsquo;dispaly\u0026rsquo; 修改為display_errors=Off  config.inc.php 新增密碼後 $cfg['Servers'][$i]['password'] = 'xxxxxx'; 出現 Access Denied for User 'root'@'localhost' (using password : NO) 錯誤\n 在 my.ini 檔案中的 [mysqld] 段落中新增一行 skip-grant-tables 重新啟動 Apache 和 MySQL   設定遠端可連線phpMyAdmin  修改 [httpd-xampp.conf] 檔案中93和105行的 Require local 改成 Require all granted 重新啟動XAMPP的 Apache 和 MySQL   參考來源 http://ep.ckvs.tyc.edu.tw/blog/files/6-5919-9316.php\n","permalink":"https://a199348006.github.io/my-blog/2022/01/xampp-setting/","summary":"更改XAMPP文字編輯器  點右上角config鈕 在Editor方塊內選文字編輯器(ex:Notepad++)   更改phpMyAdmin認證模式，開啟檔案：phpMyAdmin(config.inc.php)  將[\u0026lsquo;auth_type\u0026rsquo;] = \u0026lsquo;config\u0026rsquo;; 改成 [\u0026lsquo;auth_type\u0026rsquo;] = \u0026lsquo;cookie\u0026rsquo;; (網頁式密碼輸入對話框) 或 [\u0026lsquo;auth_type\u0026rsquo;] = \u0026lsquo;http\u0026rsquo;; (彈出式密碼輸入對話框) 如果改成\u0026rsquo;http\u0026rsquo;，則可修改密鑰 $cfg[\u0026lsquo;blowfish_secret\u0026rsquo;] = \u0026lsquo;xampp\u0026rsquo; (不改也可) 儲存後重新啟動控制面板   啟動如出現錯誤  檢查xampp是否放置於中文資料夾 點選右側NetStat鈕 ，查看80(http)、443(https)、3306(MySQL)Port是否被佔用   更改http 80port為8080port，開啟檔案：Apache(httpd.conf)   搜尋80(有兩處要改)\nListen 8080\nServerName localhost:8080\n   更改預設首頁資料夾，開啟檔案：Apache(httpd.conf)  搜尋 \u0026lsquo;htdocs\u0026rsquo; 修改路徑1：DocumentRoot \u0026ldquo;C:/xampp/htdocs/xxxxx\u0026rdquo; 修改路徑2：Directory \u0026ldquo;C:/xampp/htdocs/xxxxx\u0026rdquo;  P.S. 也可在C:\\XAMPP\\htdocs中修改index.php內容：header(\u0026lsquo;Location: \u0026lsquo;.$uri.\u0026rsquo;/xxx/\u0026rsquo;);\n 避免瀏覽器列出檔案目錄，開啟檔案：Apache(httpd.conf)  上面更改htdocs的位置下方 Options Indexes FollowSymLinks Includes ExecCGI (刪除Indexes)   更改PHP能使用短標籤，開啟檔案：PHP(php.","title":"XAMPP常用設定"}]